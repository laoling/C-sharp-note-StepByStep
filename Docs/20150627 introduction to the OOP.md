这里我们对C#中面向对象编程技术做些简单的介绍。

# 面向对象编程简介 #

这一章节我们主要从什么是面向对象编程，什么是对象等术语；OOP的技术包含哪些方面；Windows Forms程序如何使用OOP技术这几个大的方面来进行介绍。

## 面向对象编程的含义 ##

前面我们介绍的编程方法一般称为函数化编程或过程化编程，所有的功能都包含在一个或几个代码块中。

使用OOP技术，我们可以使用很多代码块，每个模块提供特定的功能，每个模块都是独立的。这样的模块化编程方式提供了极大的多样性，增加了代码重用的机会。

#### 1 对象的含义

对象是OOP程序的一个组件。这个组件封装了部分应用程序，这部分程序可以是一个过程、一些数据或一些更抽象的实体。

C#的对象是从类型中创建的，就像变量一样，对象的类型在OOP中叫做**类**。可以使用类的定义实例化对象，这表示创建类的一个实例。

###### 1.1 属性和字段

+ 可以通过属性和字段访问对象中包含的数据。
+ 包含在对象中的数据构成了对象的状态。
+ 字段和属性都可以键入，所以可以把信息存储在字段和属性中。
+ 属性和字段是不同的，因为属性不提供对数据的直接访问。(访问状态时最好提供属性，这样可以更好地控制各种行为，这个选择不会影响使用对象的代码，因为属性和字段语法是相同的。)
+ 对象的读写访问也可以由对象来定义。
  + 某些属性是只读的，只能查看值，而不能直接改动。常常通过查看几个属性，把相同的数据组合起来，这样的属性就能够节省时间和精力。
  + 某些只写的属性，其操作方式是类似的。
  + 也可以为字段和属性指定访问权限，称为可访问性。可以定义共有或私有或者更复杂的模式。

一个类包含了一些成员，这些成员一般包含了几个方面的信息：可访问性、成员名、成员的类型。

###### 1.2 方法

方法用于表示对象中的函数，与前面函数的使用方法完全类似。方法用于提供访问对象的功能。

#### 2 一切皆对象

实际上C#和.NET Framework中的所有东西都是对象。

#### 3 对象的生命周期

每个对象都有明确的生命周期，除了正在使用的正常状态外，还有两个重要的阶段：

* **构造阶段**：对象最初进行实例化的时期。这个初始化过程称为构造阶段，由构造函数完成。
* **析构阶段**：在删除一个对象时，常常需要执行一些清理工作，这由析构函数完成。

###### 3.1 构造函数

构造函数就是用于初始化数据的函数。所有的类定义都至少含有一个构造函数。这些构造函数中，可能有一个默认的构造函数，该函数没有参数，与类同名。类定义还可能包含几个带参数的构造函数，称为非默认的构造函数。

在C#中，用new关键字来调用构造函数。构造函数也可以是公共的或私有的。

一些类没有公共的构造函数，外部代码就没办法实例化他们，这些类称为不可创建的类，但后面会介绍这些类也是有用的。

###### 3.2 析构函数

.NET Framework使用析构函数清理对象。一般情况下不需要提供析构函数代码，直接默认自动执行操作。但如果删除对象实例前，需要完成一些重要的操作，就应提供特定的析构函数。

#### 4 静态和实例类成员

除了对象实例所有的属性、字段、方法外，还有静态成员（共享成员），像静态方法、静态属性、静态字段。可以把静态成员看成类的全局对象。使用静态成员的时候，可以不需要实例化对象。

eg： 前面一直用的`Console.WriteLine()` `Convert.ToString()`方法就是静态的，不需要在使用时实例化Console或Convert类。

###### 4.1 静态构造函数

一个类只能用一个静态构造函数，该构造函数不能有访问修饰符，也不能有任何参数。静态构造函数不能直接调用，只能在下述情况下执行：

* 创建包含静态构造函数的类实例化时
* 访问包含静态构造函数的类的静态成员时

无论创建了多少个类实例，其静态构造函数都只能调用一次。我们为了区分，把所有非静态构造函数称为实例构造函数。

###### 4.2 静态类

静态类只包含静态成员，不需要实例构造函数。这就是上面介绍的不能实例化的类。




## OOP技术 ##

下面讨论一些对象的其他特性：接口、继承、多态性、对象之间的关系、运算符重载、事件、引用类型和值类型。

#### 1 接口

接口是把公共实例的（非静态）方法和属性结合起来，以封装特定功能的一个集合。一旦定义了接口，就可以在类中实现，这样类就可以支持接口所指定的所有属性和成员。

注意：接口不能单独存在。接口不能包含实现其成员的任何代码，只能定义成员本身。接口实现过程必须在实现接口的类中完成。

一个类可支持多个接口，多个类也可以支持相同接口。一般发布接口后，不要轻易修改。修改接口就升级了底层代码，用户就不能正确运行接口，甚至失败。我们应该创建一个新的接口，扩展旧接口，包含一个版本号如X2。

【可删除的对象】

IDisposable接口：其对象必须实现Dispose()方法，即它们必须提供这个方法的代码。当不再需要某个对象时就调用这个方法，释放资源。

C#允许使用一种可优化这个方法的结构。using关键字可以在代码块中初始化使用重要资源的对象，会在这个代码块末尾自动调用Dispose()方法。

	<ClassName> <VariableName> = new <ClassName>()
	...
	using (<VariableName>)
	{
		...
	}

或者将初始化对象作为using语句的一部分：
	
	using (<ClassName> <VariableName> = new <ClassName>())
	{
		...
	}

#### 2 继承

继承是OOP最重要的特性之一，任何类都可以从另一个类中继承，这个类拥有它继承的类的所有成员。被继承的类叫做父类，也叫基类。注意，C#对象仅能直接派生于一个基类，当然基类也可有自己的基类。

继承性可以使一个一般的基类扩展或创建更多的特定类。

继承的可访问性：派生类不能访问基类的私有成员，派生类和外部代码仅能访问基类的公共成员。这里C#提供第三种可访问性，protected。只有派生类才能访问protected成员，外部代码不可以。

除了定义成员保护级别外，还可以为成员定义其继承行为。基类的成员可以是虚拟的，可以在继承类中重写。

基类还可以定义为抽象类，抽象类不能直接实例化。抽象类可以有抽象成员，这些成员在基类中没有实现代码，必须在派生类中提供。

最后，类可以是密封的，（seal）密封的类不能用做基类，所以没有派生类。C#中，所有对象都有一个共同的基类object。

##### 3 多态性

继承派生于相同基类在方法和属性上有一定重叠和类似，实例化对象时语法比较相近。多态则更近一步，可以把某个派生类型的变量赋给基本类型的变量。不需要强制类型转换，就可以通过这个变量调用基类的方法。注意这个变量不能调用派生类上定义的方法，若要调用，需要把基本类型变量转换为派生类变量。

在派生于同一个类的不同对象上执行任务多态性是一种有效的技巧。只有子类和孙子类在继承层次结构中有一个相同的类，他们就可以用同样的方式利用多态性。

【接口的多态性】

建立接口类型的变量，就可以在支持该接口的对象上，使用这个变量访问该接口提供的方法和属性。这就提供了以相同方式访问多个对象的简单方式，且不依赖于一个公共的基类。

#### 4 对象之间的关系

继承就是对象间的一种简单关系。当然还有其他一些重要的关系：

* 包含关系：一个类包含另一个类。
* 集合关系：一个类用作另一个类的多个实例的容器。

###### 4.1 包含关系

用一个成员字段包含对象实例，就可以实现包含关系（containment）。

这个成员时公共的，和继承一样，容器对象的用户可以访问他的方法和属性，但不能像继承那样通过派生类访问类的内部代码。

这个成员也可以是私有成员，这样用户不能直接访问任何成员，即使其中的成员是公共的。但可以使用包含类的成员访问这些私有成员。

也就是说，可以完全控制被包含的类有什么成员，如果有成员，还可以在访问被包含成员前，在包含类的成员上进行其他处理。

###### 4.2 集合关系

集合基本上是数组，集合以与其他对象相同的方式实现为类。他们通常以所存储的对象名称的复数形式来命名。

#### 5 运算符重载

使用运算符可以处理简单的变量类型，有时也可以把运算符用于从类实例化而来的对象，因为类可以包含如何处理运算符的指令。

运算符重载定义包含在所实例化的相同或不同的类中。只能重载现有的C#运算符，不能创建新的运算符。但可以为一元和二元运算符提供实现代码。

#### 6 事件

对象可以激活事件，作为它们处理的一部分。事件处理程序是一种特殊类型的函数，在事件发生时调用。后面我们会详细介绍事件。

#### 7 引用类型和值类型

C#中，数据根据变量的类型以两种方式中的一种存储在一个变量中。引用类型和值类型区别如下：

* 值类型在内存的一个地方存储它们自己和它们的内容。
* 引用类型存储指向内存中其他某个位置（称为堆）的引用，而在另一个位置存储内容。

这个问题我们不需要特别关注。只有string和object简单类型是引用类型，数组是隐式的引用类型。我们创建的类都是引用类型。


