本篇文档用于整理C#的泛型的笔记内容，这里我需要加快一点了。最近比较忙，更新一篇笔记花费的时间过长了。

# 泛型 #

C#是在C++基础上开发的。C#在第一版时却缺少了对泛型的支持。这项技术在C++中称为模板，在其中被公认为是完成任务的最佳方式。它可以在编译期间由一个类型定义派生出许多特定的类型，这节约了大量的时间和精力。C#从2.0版本开始就加入了泛型。

本章我们首先介绍泛型的概念，然后讨论.NET Framework中的一些泛型类型，将有助于更好地理解其功能和强大之处，以及在代码中需要使用的新语法。然后定义自己的泛型类型，包含泛型类、接口、方法和委托。还要进一步制定泛型类型的其他技术：default关键字和类型约束。最后讨论抗变和协变，这是C#四版中新增的两种形式的变体，在使用泛型类时提供了更大的灵活性。

## 一、泛型的概念 ##

泛型类是以实例化过程中提供的类型或类为基础建立的，可以毫不费力地对对象进行强类型化。只需要一行代码就可以解决了。

```csharp
CollectionClass<ItemClass> items = new CollectionClass<ItemClass>();
items.Add(new ItemClass());
```

尖括号语法就是把类型参数传递给泛型类型的方式。在上面的代码中应把CollectionClass<ItemsClass>看做ItemClass的CollectionClass。后面会详细看这个语法。

泛型非常适合于集合这个领域，后面介绍到System.Collection.Generic命名空间时会提及。创建一个泛型类，就可以生成一些方法，它们的签名可以强类型化为我们需要的任何类型，该类型甚至可以是值类型或引用类型，处理各自的操作。还可以把用于实例化泛型类的类型限制为支持某个给定的接口，或派生自某种类型，只允许使用类型的一个子集。泛型并不限于类，还可创建泛型接口、泛型方法（可以在非泛型类上定义），甚至泛型委托。这将极大地提高代码的灵活性，正确使用泛型可以显著缩短开发时间。

在后台.NET运行库允许在需要时动态生成泛型类。在通过实例化来请求生成之前，B的某个泛型类A甚至不存在。总之，泛型允许灵活地创建类型，处理一种或多种特定类型的对象，这些类型是在实例化时确定的，否则就使用泛型类型。

## 二、使用泛型 ##

我们先看.NET Framework提供的泛型，包括System.Collections.Generic命名空间中的类型。下面实例中我们就会使用这些类型。在之前我们先介绍一个较简单的泛型类型，即可空类型(nullable type)，他解决了值类型的一个小问题。

#### 2.1 可空类型

有时让值类型为空是很有用的（尤其是处理数据库时），泛型使用`System.Nullable<I>`类型提供了使值类型为空的一种方式。eg：

```csharp
System.Nullable<int> nullableInt;
```

运行代码声明了一个变量nullableInt，它可以拥有int变量能包含的任意值，还可以拥有值null。所以可以编写如下代码：

```csharp
nullableInt = null;
```

如果nullableInt是一个int类型的变量，上面的代码是不能编译的。前面的赋值等价于：

```csharp
nullableInt = new System.Nullable<int>();
```

与其他任何变量一样，无论是初始化为null，还是通过给它赋值来初始化，都不能在初始化之前使用它。

可以像测试引用类型一样，测试可空类型，看看它们是否为null：

```csharp
if (nullableInt == null)
{
	...
}
```

另外可以使用HasValue属性：

```csharp
if (nullableInt.HasValue)
{
	...
}
```

这不适用于引用类型，即使引用类型有一个HasValue属性，也不能使用这种方法，因为引用类型的变量值为null，就表示不存在对象，当然就不能通过对象来访问这个属性，否则会抛出一个异常。

使用value属性可以查看可空类型的值。如果HasValue是true，就说明Value属性有一个非空值。但如果HasValue是false，就说明变量被赋予了null，访问value属性会抛出System.InvalidOperationException类型的异常。

声明可空类型的变量使用语法：

```csharp
int? nullableInt;
```

int?是System.Nullable<int>的缩写，但更便于读取。在后面就使用了这个语法。

##### 2.2.1 运算符和可空类型

对于简单类型如int，可以使用+ -等运算符来处理值。而对于可空类型，这是没有区别的：包含在可空类型中的值会隐式转换为需要的类型，使用适当的运算符。这也适用于结构和自己提供的运算符。例如：

```csharp
int? op1 = 5;
int? result = op1 * 2;
```

注意，其中result变量的类型也是int?。下面的代码不会被编译：

```csharp
int? op1 = 5;
int result = op1 * 2;
```

为了使上面代码正常工作，需要进行显式转换：

```csharp
int? op1 = 5;
int result = (int)op1 * 2;
```

或者通过Value属性访问值，需要的代码如下：

```csharp
int? op1 = 5;
int result = op1.Value * 2;
```

只要op1有一个值，上面的代码就可以正常运行了。如果op1是null，就会生成System.InvalidOperationException类型的异常。

##### 2.2.2 ??运算符

为了进一步减少处理可空类型所需的代码量，使可空变量的处理变得更简单，可以使用??运算符。这个运算符称为空接合运算符(null coalescing operator)，是一个二元运算符，允许给可能等于null的表达式提供另一个值。如果第一个操作数不是null，该运算就等于第一个操作数，否则该运算符就等于第二个操作数。下面的两个表达式的作用是相同的：

```csharp
op1 ?? op2;
op1 == null ? op1 : op2;
```

在这两行代码中，op1可以是任意可空表达式，包括引用类型和更重要的可空类型。因此如果可空类型是null，就可以使用??运算符提供要使用的默认值，如下例：

```csharp
int? op1 = null;
int result = op1 * 2 ?? 5;
```

这里需要注意，在结果中放入int类型的变量result不需要显式转换。??运算符会自动处理这个转换。还可以把??等式的结果放在int?中：

```csharp
int? result = op1 * 2 ?? 5;
```

在处理可空变量时，??运算符有许多用途，它是一种提供默认值的便捷方式，不需要使用if结构中的代码块或容易引起混淆的二元运算符。

#### 2.2 System.Collections.Generic 命名空间

## 三、定义泛型类型 ##

#### 3.1 定义泛型类

#### 3.2 定义泛型接口

#### 3.3 定义泛型方法

#### 3.4 定义泛型委托

## 四、变体 ##

#### 4.1 协变

#### 4.2 抗变

