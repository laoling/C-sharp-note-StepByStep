本篇文档用于整理C#的泛型的笔记内容，这里我需要加快一点了。最近比较忙，更新一篇笔记花费的时间过长了。

# 泛型 #

C#是在C++基础上开发的。C#在第一版时却缺少了对泛型的支持。这项技术在C++中称为模板，在其中被公认为是完成任务的最佳方式。它可以在编译期间由一个类型定义派生出许多特定的类型，这节约了大量的时间和精力。C#从2.0版本开始就加入了泛型。

本章我们首先介绍泛型的概念，然后讨论.NET Framework中的一些泛型类型，将有助于更好地理解其功能和强大之处，以及在代码中需要使用的新语法。然后定义自己的泛型类型，包含泛型类、接口、方法和委托。还要进一步制定泛型类型的其他技术：default关键字和类型约束。最后讨论抗变和协变，这是C#四版中新增的两种形式的变体，在使用泛型类时提供了更大的灵活性。

## 一、泛型的概念 ##

泛型类是以实例化过程中提供的类型或类为基础建立的，可以毫不费力地对对象进行强类型化。只需要一行代码就可以解决了。

```csharp
CollectionClass<ItemClass> items = new CollectionClass<ItemClass>();
items.Add(new ItemClass());
```

尖括号语法就是把类型参数传递给泛型类型的方式。在上面的代码中应把CollectionClass<ItemsClass>看做ItemClass的CollectionClass。后面会详细看这个语法。

泛型非常适合于集合这个领域，后面介绍到System.Collection.Generic命名空间时会提及。创建一个泛型类，就可以生成一些方法，它们的签名可以强类型化为我们需要的任何类型，该类型甚至可以是值类型或引用类型，处理各自的操作。还可以把用于实例化泛型类的类型限制为支持某个给定的接口，或派生自某种类型，只允许使用类型的一个子集。泛型并不限于类，还可创建泛型接口、泛型方法（可以在非泛型类上定义），甚至泛型委托。这将极大地提高代码的灵活性，正确使用泛型可以显著缩短开发时间。

在后台.NET运行库允许在需要时动态生成泛型类。在通过实例化来请求生成之前，B的某个泛型类A甚至不存在。总之，泛型允许灵活地创建类型，处理一种或多种特定类型的对象，这些类型是在实例化时确定的，否则就使用泛型类型。

## 二、使用泛型 ##

我们先看.NET Framework提供的泛型，包括System.Collections.Generic命名空间中的类型。下面实例中我们就会使用这些类型。在之前我们先介绍一个较简单的泛型类型，即可空类型(nullable type)，他解决了值类型的一个小问题。

#### 2.1 可空类型

有时让值类型为空是很有用的（尤其是处理数据库时），泛型使用`System.Nullable<I>`类型提供了使值类型为空的一种方式。eg：

```csharp
System.Nullable<int> nullableInt;
```

运行代码声明了一个变量nullableInt，它可以拥有int变量能包含的任意值，还可以拥有值null。所以可以编写如下代码：

```csharp
nullableInt = null;
```

如果nullableInt是一个int类型的变量，上面的代码是不能编译的。前面的赋值等价于：

```csharp
nullableInt = new System.Nullable<int>();
```

与其他任何变量一样，无论是初始化为null，还是通过给它赋值来初始化，都不能在初始化之前使用它。

可以像测试引用类型一样，测试可空类型，看看它们是否为null：

```csharp
if (nullableInt == null)
{
	...
}
```

另外可以使用HasValue属性：

```csharp
if (nullableInt.HasValue)
{
	...
}
```

这不适用于引用类型，即使引用类型有一个HasValue属性，也不能使用这种方法，因为引用类型的变量值为null，就表示不存在对象，当然就不能通过对象来访问这个属性，否则会抛出一个异常。

使用value属性可以查看可空类型的值。如果HasValue是true，就说明Value属性有一个非空值。但如果HasValue是false，就说明变量被赋予了null，访问value属性会抛出System.InvalidOperationException类型的异常。

声明可空类型的变量使用语法：

```csharp
int? nullableInt;
```

int?是System.Nullable<int>的缩写，但更便于读取。在后面就使用了这个语法。

##### 2.2.1 运算符和可空类型

对于简单类型如int，可以使用+ -等运算符来处理值。而对于可空类型，这是没有区别的：包含在可空类型中的值会隐式转换为需要的类型，使用适当的运算符。这也适用于结构和自己提供的运算符。例如：

```csharp
int? op1 = 5;
int? result = op1 * 2;
```

注意，其中result变量的类型也是int?。下面的代码不会被编译：

```csharp
int? op1 = 5;
int result = op1 * 2;
```

为了使上面代码正常工作，需要进行显式转换：

```csharp
int? op1 = 5;
int result = (int)op1 * 2;
```

或者通过Value属性访问值，需要的代码如下：

```csharp
int? op1 = 5;
int result = op1.Value * 2;
```

只要op1有一个值，上面的代码就可以正常运行了。如果op1是null，就会生成System.InvalidOperationException类型的异常。

##### 2.2.2 ??运算符

为了进一步减少处理可空类型所需的代码量，使可空变量的处理变得更简单，可以使用??运算符。这个运算符称为空接合运算符(null coalescing operator)，是一个二元运算符，允许给可能等于null的表达式提供另一个值。如果第一个操作数不是null，该运算就等于第一个操作数，否则该运算符就等于第二个操作数。下面的两个表达式的作用是相同的：

```csharp
op1 ?? op2;
op1 == null ? op1 : op2;
```

在这两行代码中，op1可以是任意可空表达式，包括引用类型和更重要的可空类型。因此如果可空类型是null，就可以使用??运算符提供要使用的默认值，如下例：

```csharp
int? op1 = null;
int result = op1 * 2 ?? 5;
```

这里需要注意，在结果中放入int类型的变量result不需要显式转换。??运算符会自动处理这个转换。还可以把??等式的结果放在int?中：

```csharp
int? result = op1 * 2 ?? 5;
```

在处理可空变量时，??运算符有许多用途，它是一种提供默认值的便捷方式，不需要使用if结构中的代码块或容易引起混淆的二元运算符。

#### 2.2 System.Collections.Generic 命名空间

我们之前所有的应用程序都包含了下面的命名空间：

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
```

System命名空间包含.NET应用程序使用的大多数基本类型。System.Text命名空间包含与字符串处理和编码相关的类型，System.Linq命名空间后面会说。System.Collections.Generic命名空间包含什么类型？

这个命名空间包含用于处理集合的泛型类型，使用得非常频繁，用using语句配置它，使用时就不必加限定符了。

使用泛型类型，下面将介绍它们可以使工作更容易完成，可以毫不费力地创建强类型化的集合类。这里我们先介绍System.Collections.Generic命名空间中的两个类型，后面会介绍更多类型。

+ `List<T>` T类型对象的集合
+  `Dictionary<K, V>` 与K类型的键值相关的V类型的项的集合

##### 2.2.1 `List<T>`

`List<T>`泛型集合类型更加快捷、更易于使用；这样就不必像上一章那样，从CollectionBase中派生一个类，然后实现需要的方法。它的另一个好处是正常情况下需要实现的许多方法已经自动实现了。

创建T类型对象的集合需要下面的代码：

```csharp
List<T> myCollection = new List<T>();
```

这就足够了。没有定义类、实现方法和进行其他操作。还可以把`List<T>`对象传给构造函数，在集合中设置项的起始列表。使用这个语法实例化的对象将支持下面的方法和属性（其中提供给`List<T>`泛型的类型是T）。

+ `int Count`  该属性给出集合中项的个数
+ `void Add(T item)`  把一个项添加到集合中
+ `void AddRange(IEnumerable<T>)`  把多个项添加到集合中
+ `IList<T> AsReadOnly()`  给集合返回一个只读接口
+ `int Capacity`  获取或设置集合可以包含的项数
+ `void Clear()`  删除集合中的所有项
+ `bool Contains(T item)`  确定item是否包含在集合中
+ `void CopyTo(T[] array, int index)`  把集合中的项复制到数组array中，从数组的索引index开始
+ `IEnumberator<T> GetEnumerator()`  获取一个`IEnumerator<T>`实例，用于迭代集合。注意，返回的接口强类型化为T，所以在foreach循环中不需要类型转换
+ `int IndexOf(T item)`  获取item的索引，如果集合中并未包含该项，就返回-1
+ `void Insert(int index, T item)`  把item插入到集合的指定索引位置上
+ `bool Remove(T item)`  从集合中删除第一个item，并返回true；如果item不包含在集合中，就返回false
+ `void RemoveAt(int index)`  从集合中删除索引index处的项

`List<T>`还有一个Item属性，允许进行类似于数组的访问，如下：

```csharp
T itemAtIndex2 = myCollectionOfT[2];
```

这个类型还支持其他几个方法，但只要掌握上面这些，就完全可以开始使用该类了。

*我们在使用这个类时遇到一个问题，为什么不从CollectionBase中派生类？*

实际上我们很多情况下都不会从CollectionBase中派生类。知道内部工作原理肯定很好，因为`List<T>`以相同的方式工作，但CollectionBase主要用于向后兼容。使用CollectionBase的唯一场合是要更多地控制向类用户展示的成员。例如希望集合类Add()方法使用内部访问修饰符，则使用CollectionBase是最佳选择。

##### 2.2.2 对泛型列表进行排序和搜索

对泛型列表进行排序和对其他列表进行排序是一样的。前面说了如何使用IComparer和IComparable接口比较两个对象，然后对该类型的对象列表排序。这里唯一的区别是：可以使用泛型接口`IComparer<T>`和`IComparable<T>`，它们提供了略有区别且针对特定类型的方法。

它们之间的区别：

* `int IComparable<T>.CompareTo(T otherObj)`和`int IComparable.CompareTo(object, otherObj)`
  区别：在泛型版本中是强类型化的。

* `bool IComparable<T>.Equals(T otherObj)`
  在非泛型接口中不存在，可以使用`object.Equals()`替代。

* `int IComparer<T>.Compare(T objectA, T objectB)`和       `int IComparer.Compare(object objectA, object objectB)`
  区别：在泛型版本中是强类型化的。

* `bool IComparer<T>.Equals(T objectA, T objectB)`
  在非泛型接口中不存在，可以改用`object.Equals()`.

* `int IComparer<T>.GetHashCode(T objectA)`
  在非泛型接口中不存在，可以改用继承的`object.GetHashCode()`.

要对`List<T>`排序，可以在要排序的类型上提供`IComparable<T>`接口，或者提供`IComparer<T>`接口。另外还可以提供泛型委托，作为排序方法。从了解工作原理角度来看，这很有趣，因为实现上述接口并不比实现其非泛型版本更麻烦。

一般情况下，给列表排序需要有一个方法来比较两个T类型的对象。要在列表中搜索，也需要一个方法来检查T类型的对象，看看它是否满足某个条件。定义这样的方法很简单，这里给出两个可以使用的泛型委托类型：

* `Comparison<T>`这个委托类型用于排序方法，其返回类型和参数如下：

```csharp
int method(T objectA, T objectB)
```

* `Predicate<T>`这个委托类型用于搜索方法，其返回类型和参数如下：

```csharp
bool method(T targetObject)
```

可以定义任意多个这样的方法，使用它们实现`List<T>`的搜索和排序方法。

##### 2.2.3 `Dictionary<K, V>`

这个类型可以定义键值对的集合。与前面介绍的其他泛型集合类型不同，这个类需要实例化两个类型，分别用于键和值，以表示集合中的各个项。

实例化`Dictionary<K, V>`对象后，就可以像在继承自DictionaryBase的类上那样，对它执行相同的操作，但要使用已有的类型安全的方法和属性。例如可以使用强类型化的Add()方法添加键值对：

```csharp
Dictionary<string, int> things = new Dictionary<string, int>();
things.Add("Green Things", 29);
things.Add("Blue Things", 94);
things.Add("Yellow Things", 34);
things.Add("Red Things", 52);
things.Add("Brown Things", 27);
```

可以使用Keys和Values属性迭代集合中的键和值：

```csharp
foreach (string key in things.Keys)
{
	Console.WriteLine(key);
}

foreach (int value in things.Values)
{
	Console.WriteLine(value);
}
```

还可以迭代集合中的各个项，把每个项作为一个`KeyValuePair<K, V>`实例来获取，这与前面介绍的DIctionaryEntry对象十分相似：

```csharp
foreach (KeyValuePair<string, int> thing in things)
{
	Console.WriteLine("{0} = {1}",thing.Key, thing.Value);
}
```

对于`Dictionary<K, V>`要注意的一点是，每个项的键都必须是唯一的。如果要添加的项的键与已有的键相同，就会抛出ArgumentException异常。所以`Dictionary<K, V>`允许把`IComparer<K>`接口传递给其构造函数。如果要把自己的类用作键，且它们不支持`IComparable`或`IComparable<K>`接口，或者要使用非默认的过程比较对象，就必须把`IComparer<K>`接口传递给其构造函数。

eg：上面的例子中可以使用不区分大小写的方法来比较字符串键：

```csharp
Dictionary<string, int> things = new Dictionary<string, int>(StringComparer.CurrentCultureIgnoreCase);
```

如果使用下面的键，就会得到一个异常：

```csharp
things.Add("Green things", 29);
things.Add("Green things", 94);
```

也可以给构造函数传递初始容量（使用int）或项的集合（使用`IDictionary<K, V>`接口）。

## 三、定义泛型类型 ##

#### 3.1 定义泛型类

#### 3.2 定义泛型接口

#### 3.3 定义泛型方法

#### 3.4 定义泛型委托

## 四、变体 ##

#### 4.1 协变

#### 4.2 抗变

