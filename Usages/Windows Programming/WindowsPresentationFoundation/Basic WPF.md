本章笔记我们介绍些关于WPF的基础知识，我们先只停留在认识基础的程度，后面我们还会进一步深入学习WPF的相关知识。

# Windows Presentation Foundation（WPF）基础知识 #

## 一、WPF概述 ##

WPF（Windows Presentation Foundation）适用于Windows的现代图形显示系统。与之前的其他技术相比，WPF发生了根本性变化，引入了**内置硬件加速**和**分辨率无关**等创新功能，后面我们详细介绍。

如果要构建桌面模式的（Windows下的）富桌面应用程序，WPF无疑是最佳的工具包。事实上，WPF是针对Windows版本的唯一通用工具包。比较起来，Microsoft推出的Metro工具包只适用于Windows8系统。WPF的应用范围却广泛的多，它甚至可运行在仍在很多大企业中使用的Windows XP上；唯一的局限性在于您必须对Visual Studio进行配置，使其将较为陈旧的.NET Framework作为目标。

本章将首先介绍WPF的体系结构，然后讨论WPF如何处理可变屏幕分辨率，将概述WPF的核心程序集和类，并将介绍WPF如何从初始版本演变为WPF4.5。

### 1、Windows图形化演化

在WPF面世之前的十五年，Windows开发人员一直使用本质上相同的显示技术。究其原因，是由于此前的每个传统Windows应用程序都依靠Windows操作系统的如下两个由来已久的部分来创建用户界面：

* **User32**：该部分为许多元素（如窗口、按钮和文本框等）提供了熟悉的Windows外观。
* **GDI/GDI+**：该部分为渲染简单形状、文本以及图像提供了绘图支持，但增加了复杂程度（且通常性能较差）。

历经多年发展，这两种技术都得到了改进，而且开发人员使用的与其交互的API也已发生了巨大变化。但在构建应用程序时，不管是窗体还是基于MFC的C++代码，底层都是使用Windows相同部分来完成工作的。不同框架工具只是为与User32和GDI进行交互提供了不同的封装器而已。这些框架工具能提高效率，降低复杂性，并提供了更多预置特性，从而使开发人员不必再自行编写底层代码，但这些框架工具不可能消除在10年前设计的系统组件的基本限制。

##### 1.1 DirectX：新的图形引擎

针对User32和GDI库的限制Windows曾提供了一个解决方案：DirectX。DirectX起初是一个易于出错的组合性质的工具包，用于在Windows平台上开发游戏。DirectX在设计上关注的重点是速度。

为此，Windows和显卡供应商密切合作，以便为DirectX提供复杂的纹理映射、特殊效果以及三维图形所需的硬件加速功能。

现在DirectX已经历数年发展，趋于成熟。已成为Windows基本组成部分，可支持所有现代显卡。然而，DirectX编程API一直未背离设计初衷，仍主要作为游戏开发人员的工具包。因为DirectX的复杂性，它几乎从未用于开发传统类型的Windows应用程序。

Windows为了扭转这种局面。在WPF中，底层图形技术不再是GDI/GDI+，而是DirectX。也就是说，不管创建哪种用户界面，WPF应用程序在底层都是使用DirectX。

这意味着，不论设计复杂的三维图形，还是仅绘制几个按钮和纯文本，所有绘图工作都是通过DirectX管线完成的。因此，即使是最普通的商业应用程序也能使用丰富的效果，如半透明和反锯齿。在硬件加速方面也带来了好处，DirectX在渲染图形时会将尽可能多的工作递交给图形处理单元去处理。

不过，仍有一个User32组件得以保留，该组件只用于有限的范围。因为对于特定服务，WPF仍依赖于User32，如处理和路由输入信息以及区分哪个应用程序实际拥有屏幕的哪一部分。但所有绘图操作都是由DirectX完成的。

##### 1.2 硬件加速与WPF

显卡在支持特定渲染特性和优化方面是有区别的。令人感到庆幸的是，这并不是什么问题，原因有两点。

* 首先，当今大多数计算机配备的显卡硬件都足以支持3D绘图和动画等WPF功能。即使是使用集成图形处理器的便携式电脑和桌面计算机也同样如此。
* 其次，WPF为要完成的所有工作都预备了软件处理方式。这意味着，WPF的智能程度足够高，会尽量采用硬件优化方式，但如有必要，它也可采用软件方式来完成同样的工作。因此，如果在配备旧式显卡的计算机上运行WPF应用程序，界面仍将按其设计方式显示。当然速度会慢很多，且不能流畅运行富WPF应用程序。

### 2、WPF：高级API

如果WPF仅通过DirectX提供硬件加速功能，那么它只能算一项重要改进，而不是革命性变化。实际上，WPF包含了一整套面向应用程序编程人员的高级服务。

下面列出WPF引入到Windows编程领域中的一些最重要变化：

* 类似Web的布局模型。与通过特性坐标将控件固定在具体位置不同，WPF十分注重灵活的流式布局，根据控件的内容灵活地排列控件，从而使用户界面能适应变化幅度大的内容以及不同的语言。
* 丰富的绘图模型。与逐像素进行绘制不同，在WPF中可直接处理图元——基本形状、文本块以及其他图形元素。也可使用其他新特性，如真正的透明控件、放置多层并具有不同透明度内容的功能以及本地3D支持。
* 丰富的文本模型。WPF为Windows应用程序提供了在用户界面的任何位置显示丰富的样式化文本的功能。甚至可将文本和列表、浮动的图形以及其他用户界面元素结合起来。并且如果需要显示大量文本，还可使用高级的文档显示特性，例如换行、分列和对齐，以提高可读性。
* 作为首要编程概念的动画。在WPF中，不必再用计时器来强制窗体重绘自身。与此相反，动画成为WPF框架的固有部分。在WPF中可使用声明式标签定义动画，WPF会自动让他们运动起来。
* 支持音频和视频媒体。以前的用户界面开发工具包对多媒体的处理有很大的限制。但WPF支持播放任何Windows媒体播放器所支持的音频和视频文件，并允许同时播放多个媒体文件。更引人注目的是，WPF提供了允许在用户界面的其他部分集成视频内容的工具，还允许添加特效技巧。
* 样式和模板。通过样式可实现显示格式的标准化，并可在整个应用程序中反复使用。通过模板可改变元素的渲染方式，甚至改变核心控件的渲染方式。在创建现代的具有皮肤的用户界面时，从来都不像现在这样方便。
* 命令。大多数用户已认识到，通过菜单或工具栏触发Open命名并没有什么区别，最终结果是相同的。现在通过代码抽象，可在特定位置定义应用程序命名并将其链接到多个控件上。
* 声明式用户界面。尽管可编写代码来创建WPF窗口，但VS提供了另一种方式。它将每个窗口的内容串行化到XAML文档中的一组XML标签中。其优点是用户界面和代码完全分离，并且图形设计人员可使用专业工具编辑XAML，并最终润色应用程序的前端界面。XAML是Extensible Application Markup Language的缩写。
* 基于页面的应用程序。可使用WPF创建类似于浏览器的应用程序，此类应用程序可通过前进后退导航按钮在一组页面中移动。由WPF来处理那些纷繁的细节，如页面历史。甚至可将项目部署为运行与IE中的基于浏览器的应用程序。

### 3、分辨率无关性

传统的Windows应用程序都会受特定的假定屏幕分辨率的限制。在设计窗口时，开发人员通常假定标准的显示器分辨率（如1366*768像素），并针对更小或更大的分辨率尽量保持窗口能够合理的改变尺寸。

问题是传统的Windows应用程序的用户界面是不可伸缩的。因此，如果使用更高的显示器分辨率，就会更紧密地排列像素，应用程序窗口将变得更小并更难以阅读。特别是对于使用像素排列更加紧密的新型显示器，当以较高分辨率运行时，问题更趋严重。例如通常发现用户使用某些显示器排列密度是120dpi或144dpi，超过更常见的96dpi。当这些显示器使用它们默认的分辨率时，像素会以更紧密的方式显示，使控件和文本变得更小。

理想情况下，是应用程序使用更高的像素密度显示更多细节。例如高分辨率显示器可显示相同大小的工具栏图标，但使用更多像素显示更清晰的图形。这样可保持基本布局，但增加了清晰度和细节。

出于多种原因，这种解决方法在过去是无法实现的。尽管可改变用GDI库绘制的图形内容的大小，但User32不支持真正的缩放。

这个问题在WPF中不复存在，因为WPF自行渲染所有用户界面元素，从简单的形状到通用控件。所以，如果在计算机显示器上创建一个1英寸宽的按钮，在更高分辨率的显示器上它仍能保持1英寸的宽度——WPF只是使用更多像素更详细地渲染这个按钮罢了。

这里做了总体性描述，并通过几个细节进行了解释。最重要的是要认识到WPF根据系统DPI设置进行缩放，并不根据物理显示器设备的DPI进行缩放。这是十分合理的——毕竟在100英寸的投影仪上显示应用程序，您可能会站在投影仪后面几步远的地方，并希望看到特大版本的窗口。不希望WPF处理到正常大小。同样，如果使用高分辨率便携显示器，您可能希望窗口稍微小些。更进一步说，不同用户有不同偏好。有些用户可能希望显示更丰富的细节，而另一些用户肯呢过希望显示更多内容。

那么WPF如何确定应用程序窗口的大小呢？

简单来讲，就是当WPF计算窗口尺寸时使用系统DPI设置。但要想理解底层工作原理，进一步探讨WPF度量系统是很有帮助的。

##### 3.1 WPF单位

WPF窗口以及其中所有元素都使用与设备无关的单位进行度量。一个与设备无关的单位被定义为1/96英寸。

这样在设备上看一个表示的‘像素’就是有大有小的。

##### 3.2 系统DPI

如果改变系统DPI设置，WPF按钮示例就和其他类型Windows应用程序完全不同了。在上一代Windows中，该特性有时称为大字体。因为那时系统DPI会影响字体的大小，其他细节通常却不变。

这正是WPF的不同之处。WPF本身就可以十分轻松地支持DPI设置。WPF使用下面的公式计算如何将逻辑单位变换为物理设备像素：

	[物理单位尺寸] = [设备无关单位尺寸] X [系统DPI]

如果只用于按钮，这种自动缩放意义不大。但WPF对它所显示的任何内容都使用设备无关单位，包括形状、控件、文本以及其他放在窗口中的内容。所以可将系统dpi改为任何所希望的数值，WPF将无缝地调整应用程序的尺寸。

##### 3.3 位图和矢量图形

当使用普通控件时，自然可利用WPF的分辨无关性。WPF会负责确保任何显示内容都能自动地具有正确的尺寸。

但是，如果准备在应用程序中包含图像，偶尔可能出现问题。例如在传统Windows应用程序中，开发人员为工具栏命令按钮使用非常小的位图，但在WPF中这样并非一种理想方法，因为当根据系统DPI进行放大或缩小时，位图可能出现伪影（变得模糊）。

反而，当设计WPF用户界面时，即使是最小图标，通常也使用矢量图形来实现。矢量图形被定义为一系列的形状，并且它们能够很容易的缩放为任何尺寸。

分辨率无关性的重要性无论如何强调都不过分。因为乍一看，对于这个由来已久的问题（该问题确实如此），它看起来像是简单的、优美的解决方法。但为了设计完全可缩放的用户界面，开发人员需要接受一种新的思想。

### 4、WPF体系结构

WPF使用多层体系结构。

在顶层，应用程序与完全托管C#代码编写的一组高层服务进行交互。至于将.NET对象转换为Direct3D纹理和三角形的实际工作，是在后台由一个名为milcore.dll的低级非托管组件完成的。milcore.dll是使用非托管代码实现的，因为它需要和Direct3D紧密集成，并且它对性能极其敏感。

它包含的一些重要组件如下：

* PresentationFramework.dll包含WPF顶层的类型，包括那些表示窗口、面板以及其他类型控件的类型。它还实现了高层编程抽象，如样式。开发人员直接使用的大部分类都来自这个程序集。
* PresentationCore.dll包含了基础类型，如UIElement类和Visual类，所有形状类和控件类都继承自这两个类。如果不需要窗口和控件抽象层的全部特征，可使用这一层。而且仍能利用WPF的渲染引擎。
* WindowsBase.dll包含了更多基本要素，这些要素具有在WPF之外重用的潜能，如DispatcherObject类和DependencyObject类，这两个类引入了依赖项属性。
* milcore.dll是WPF渲染系统的核心，也是媒体集成层（MIL）的基础。其合成引擎将可视化元素转换为Direct3D所期望的三角形和纹理。尽管将milcore.dll视为WPF的一部分，但它也是Win7的核心系统组件之一。实际上，桌面窗口管理器（DWM）使用milcore.dll渲染桌面。
* WindowsCodecs.dll是一套提供图像支持的低级API，如处理显示及缩放位图和JPEG图像。
* Direct3D是一套低级API，WPF应用程序中所有图形都是由它进行渲染。
* User32用于决定哪些程序实际占有桌面的哪一部分。所以它仍被包含在WPF中，但不再负责渲染通用控件。

需要认识到最重要的事实是，在WPF中所有绘图内容都由Direct3D渲染。不管使用普通显卡还是使用功能更强大的显卡，不管使用基本控件还是绘制更复杂的内容，也不管是在什么系统上运行应用程序，情况都是如此。甚至二维图形和普通文本也被转换为三角形并被传送到Direct3D管线，而不使用GDI+或User32渲染图形。

**类层次结构**

我们先分析下构成WPF基本控件集合的类的层次结构是很有帮助的。

下面我们将简要介绍核心类：

	WPF核心名称控件以System.Windows开头（如System.Windows System.Windows.Controls
	以及 System.Windows.Media）。唯一例外是由System.Windows.Forms
	开头的命名空间，它们是Windows窗体工具包的一部分。

1. **System.Threading.DispatcherObject类**

	WPF应用程序使用为人熟知的单线程亲和模型（STA），这意味着整个用户界面由单个线程拥有。从另一个线程与用户界面元素进行交互是不安全的。为方便使用此模型，每个WPF应用程序由协调消息的调度程序管理。通过继承自DispatcherObject类，用户界面中的每个元素都可以检查代码是否在正确的线程上运行，并能通过访问调度程序为用户界面线程封送代码。

2. **System.Windows.DependencyObject类**

	在WPF中，主要通过属性与屏幕上的元素进行交互。在早期设计阶段，WPF的设计者决定创建一个更加强大的属性模型，该模型支持许多特性，例如更改通知、默认值继承以及减少属性存储空间。最终结果就是依赖项属性特性。通过继承自DependencyObject类，WPF类可获得对依赖项属性的支持。

3. **System.Windows.Media.Visual类**

	在WPF中窗口显示的每个元素本质上都是Visual对象。可将Visual类视为绘图对象。其中封装了绘图指令、如何执行绘图的附加细节以及基本功能。Visual类还在托管的WPF库和渲染桌面的milcore.dll程序集之间提供了链接。任何继承自Visual的类都能在窗口上显示出来。

4. **System.Windows.UIElement类**

	UIElement类增加了对WPF本质特征的支持，如布局、输入、焦点和事件。例如这里定义两个步骤的测量和排列布局过程。在该类中，原始的鼠标单击和按键操作被转换为更有用的事件，如MouseEnter事件。与属性类似，WPF实现了增强的成为路由事件的事件路由系统。最后，UIElement类中还添加了对命令的支持。

5. **System.Windows.FrameworkElement类**

	FrameworkElement类是WPF核心继承树中的最后一站。该类实现了一些全部由UIElement类定义的成员。例如，UIElement类为WPF布局系统设置了基础，但FrameworkElement类提供了支持它的重要属性（如HorizontalAlignment和Margin属性）。UIElement类还添加了对数据绑定、动画以及样式等核心特性的支持。

6. **System.Windows.Shapes.Shape类**

	基本的形状类（如Rectangle类、Polygon类、Ellipse类、Line类以及Path类）都继承自该类。可将这些形状类与更传统的Windows小组件结合使用。

7. **System.Windows.Controls.Control类**

	控件（Control）是可与用户进行交互的元素。控件显示包括TextBox类、Button类和ListBox类等。Control类为设置字体以及前景色与背景色提供了附加属性。但最令人感兴趣的细节是模板支持，通过模板支持，可使用自定义风格的绘图替换控件的标准外观。

8. **System.Windows.Controls.ContentControl类**

	ContentControl类是所有具有单一内容的控件的基类，包括简单的标签乃至窗口的所有内容。该模型给人印象最深刻的部分是：控件中的单一内容可以是普通字符串乃至具有其他形状和控件组合的布局面板。

9. **System.Windows.Controls.ItemsControl类**

	ItemsControl类是所有显示选项集合的控件的基类，如ListBox和TreeView控件。列表控件十分灵活——例如使用ItemsControl类的内置特征，可将简单的ListBox控件变换成单选按钮列表、复选框控件列表、平铺的图像或是您所选择的完全不同的元素组合。

10. **System.Windows.Controls.Panel类**

	Panel类是所有布局容器的基类，布局容器是可包含一个或多个子元素、并按特定规则对子元素进行排列的元素。这些容器是WPF布局系统的基础，要以最富有吸引力、最灵活的方式安排内容，使用这些容器是关键所在。

注意：在Windows窗体编程中，窗体中的每个可视化项都称为控件。在WPF中，情况不再如此，可视化内容元素被称为元素（element），只有部分元素是控件：控件是那些能够接收焦点并能与用户进行交互的元素。

更令人费解的是，许多元素是在System.Windows.Controls名称空间中定义的，但它们并不是继承自System.Windows.Controls.Control类，并且不被认为是控件。Panel类便是其中一例。

### 5、WPF4.5

WPF是一种成熟的技术。它是几个已经发布的.NET平台的一部分，并通过以下版本不断地进行完善：

* **WPF3.0**。这是WPF的第一个正式版本，它与另外两种新技术同时发布：WCF和WF。这三种新技术合称为.NET Framework3.0。
* **WPF3.5**。作为.NET Framework 3.5的一部分发布。新版本WPF的新特性主要是一些小的改进，包括错误修复和性能改进。
* **WPF3.5SP1**。当发布.NET Framework SP1时，WPF设计人员抓住这个机会增添了一些新功能，例如平滑图形效果以及高级的DataGrid控件。
* **WPF4.0**。该WPF版本做了大量改进，包括更好的渲染文本、动画更自然流畅以及支持多点触控。
* **WPF4.5**。相当于上述版本更新，迄今为止，这一最新WPF对于WPF4所做的更新是最少的，这也表明WPF技术已经走向成熟。除纠正一些一般性错误并对性能做了调整外，WPF4.5还对数据绑定系统做了大量完善工作，比如完善了数据绑定表达式、可视化，并可以支持INotifyDataError接口以及数据视图同步。

##### 5.1 WPF工具包

在将新控件集成到.NET平台的WPF库之前，通常首先将新控件放入被称为WPF工具包（WPF Toolkit）的Microsoft下载中。WPF工具包不仅是预览WPF未来方向的场所，还是非常好的实用组件和控件的源，使得在正常的WPF发布周期外可使用这些控件和组件。例如WPF没有提供任何类型的制图工具，但WPF工具包提供了一套控件用于创建柱状图、饼图、气泡图、散点图以及线图。

##### 5.2 Visual Studio 2012

这里会指定使用Visual Studio进行界面开发。当然实际中你也可以手工编写或使用面向图形设计的工具Expression Blend构建。

## 二、XAML ##

## 三、布局（Layout） ##

注：我们将第二三部分分为另外的文档进行编写，以此来减少篇幅。

