本章笔记我们介绍些关于WPF的基础知识，我们先只停留在认识基础的程度，后面我们还会进一步深入学习WPF的相关知识。

# Windows Presentation Foundation（WPF）基础知识 #

## 一、WPF概述 ##

WPF（Windows Presentation Foundation）适用于Windows的现代图形显示系统。与之前的其他技术相比，WPF发生了根本性变化，引入了**内置硬件加速**和**分辨率无关**等创新功能，后面我们详细介绍。

如果要构建桌面模式的（Windows下的）富桌面应用程序，WPF无疑是最佳的工具包。事实上，WPF是针对Windows版本的唯一通用工具包。比较起来，Microsoft推出的Metro工具包只适用于Windows8系统。WPF的应用范围却广泛的多，它甚至可运行在仍在很多大企业中使用的Windows XP上；唯一的局限性在于您必须对Visual Studio进行配置，使其将较为陈旧的.NET Framework作为目标。

本章将首先介绍WPF的体系结构，然后讨论WPF如何处理可变屏幕分辨率，将概述WPF的核心程序集和类，并将介绍WPF如何从初始版本演变为WPF4.5。

### 1、Windows图形化演化

在WPF面世之前的十五年，Windows开发人员一直使用本质上相同的显示技术。究其原因，是由于此前的每个传统Windows应用程序都依靠Windows操作系统的如下两个由来已久的部分来创建用户界面：

* **User32**：该部分为许多元素（如窗口、按钮和文本框等）提供了熟悉的Windows外观。
* **GDI/GDI+**：该部分为渲染简单形状、文本以及图像提供了绘图支持，但增加了复杂程度（且通常性能较差）。

历经多年发展，这两种技术都得到了改进，而且开发人员使用的与其交互的API也已发生了巨大变化。但在构建应用程序时，不管是窗体还是基于MFC的C++代码，底层都是使用Windows相同部分来完成工作的。不同框架工具只是为与User32和GDI进行交互提供了不同的封装器而已。这些框架工具能提高效率，降低复杂性，并提供了更多预置特性，从而使开发人员不必再自行编写底层代码，但这些框架工具不可能消除在10年前设计的系统组件的基本限制。

##### 1.1 DirectX：新的图形引擎

针对User32和GDI库的限制Windows曾提供了一个解决方案：DirectX。DirectX起初是一个易于出错的组合性质的工具包，用于在Windows平台上开发游戏。DirectX在设计上关注的重点是速度。

为此，Windows和显卡供应商密切合作，以便为DirectX提供复杂的纹理映射、特殊效果以及三维图形所需的硬件加速功能。

现在DirectX已经历数年发展，趋于成熟。已成为Windows基本组成部分，可支持所有现代显卡。然而，DirectX编程API一直未背离设计初衷，仍主要作为游戏开发人员的工具包。因为DirectX的复杂性，它几乎从未用于开发传统类型的Windows应用程序。

Windows为了扭转这种局面。在WPF中，底层图形技术不再是GDI/GDI+，而是DirectX。也就是说，不管创建哪种用户界面，WPF应用程序在底层都是使用DirectX。

这意味着，不论设计复杂的三维图形，还是仅绘制几个按钮和纯文本，所有绘图工作都是通过DirectX管线完成的。因此，即使是最普通的商业应用程序也能使用丰富的效果，如半透明和反锯齿。在硬件加速方面也带来了好处，DirectX在渲染图形时会将尽可能多的工作递交给图形处理单元去处理。

不过，仍有一个User32组件得以保留，该组件只用于有限的范围。因为对于特定服务，WPF仍依赖于User32，如处理和路由输入信息以及区分哪个应用程序实际拥有屏幕的哪一部分。但所有绘图操作都是由DirectX完成的。

##### 1.2 硬件加速与WPF

显卡在支持特定渲染特性和优化方面是有区别的。令人感到庆幸的是，这并不是什么问题，原因有两点。

* 首先，当今大多数计算机配备的显卡硬件都足以支持3D绘图和动画等WPF功能。即使是使用集成图形处理器的便携式电脑和桌面计算机也同样如此。
* 其次，WPF为要完成的所有工作都预备了软件处理方式。这意味着，WPF的智能程度足够高，会尽量采用硬件优化方式，但如有必要，它也可采用软件方式来完成同样的工作。因此，如果在配备旧式显卡的计算机上运行WPF应用程序，界面仍将按其设计方式显示。当然速度会慢很多，且不能流畅运行富WPF应用程序。

### 2、WPF：高级API

如果WPF仅通过DirectX提供硬件加速功能，那么它只能算一项重要改进，而不是革命性变化。实际上，WPF包含了一整套面向应用程序编程人员的高级服务。

下面列出WPF引入到Windows编程领域中的一些最重要变化：

* 类似Web的布局模型。与通过特性坐标将控件固定在具体位置不同，WPF十分注重灵活的流式布局，根据控件的内容灵活地排列控件，从而使用户界面能适应变化幅度大的内容以及不同的语言。
* 丰富的绘图模型。与逐像素进行绘制不同，在WPF中可直接处理图元——基本形状、文本块以及其他图形元素。也可使用其他新特性，如真正的透明控件、放置多层并具有不同透明度内容的功能以及本地3D支持。
* 丰富的文本模型。WPF为Windows应用程序提供了在用户界面的任何位置显示丰富的样式化文本的功能。甚至可将文本和列表、浮动的图形以及其他用户界面元素结合起来。并且如果需要显示大量文本，还可使用高级的文档显示特性，例如换行、分列和对齐，以提高可读性。
* 作为首要编程概念的动画。在WPF中，不必再用计时器来强制窗体重绘自身。与此相反，动画成为WPF框架的固有部分。在WPF中可使用声明式标签定义动画，WPF会自动让他们运动起来。
* 支持音频和视频媒体。以前的用户界面开发工具包对多媒体的处理有很大的限制。但WPF支持播放任何Windows媒体播放器所支持的音频和视频文件，并允许同时播放多个媒体文件。更引人注目的是，WPF提供了允许在用户界面的其他部分集成视频内容的工具，还允许添加特效技巧。
* 样式和模板。通过样式可实现显示格式的标准化，并可在整个应用程序中反复使用。通过模板可改变元素的渲染方式，甚至改变核心控件的渲染方式。在创建现代的具有皮肤的用户界面时，从来都不像现在这样方便。
* 命令。大多数用户已认识到，通过菜单或工具栏触发Open命名并没有什么区别，最终结果是相同的。现在通过代码抽象，可在特定位置定义应用程序命名并将其链接到多个控件上。
* 声明式用户界面。尽管可编写代码来创建WPF窗口，但VS提供了另一种方式。它将每个窗口的内容串行化到XAML文档中的一组XML标签中。其优点是用户界面和代码完全分离，并且图形设计人员可使用专业工具编辑XAML，并最终润色应用程序的前端界面。XAML是Extensible Application Markup Language的缩写。
* 基于页面的应用程序。可使用WPF创建类似于浏览器的应用程序，此类应用程序可通过前进后退导航按钮在一组页面中移动。由WPF来处理那些纷繁的细节，如页面历史。甚至可将项目部署为运行与IE中的基于浏览器的应用程序。

### 3、分辨率无关性

传统的Windows应用程序都会受特定的假定屏幕分辨率的限制。在设计窗口时，开发人员通常假定标准的显示器分辨率（如1366*768像素），并针对更小或更大的分辨率尽量保持窗口能够合理的改变尺寸。

问题是传统的Windows应用程序的用户界面是不可伸缩的。因此，如果使用更高的显示器分辨率，就会更紧密地排列像素，应用程序窗口将变得更小并更难以阅读。特别是对于使用像素排列更加紧密的新型显示器，当以较高分辨率运行时，问题更趋严重。例如通常发现用户使用某些显示器排列密度是120dpi或144dpi，超过更常见的96dpi。当这些显示器使用它们默认的分辨率时，像素会以更紧密的方式显示，使控件和文本变得更小。

理想情况下，是应用程序使用更高的像素密度显示更多细节。例如高分辨率显示器可显示相同大小的工具栏图标，但使用更多像素显示更清晰的图形。这样可保持基本布局，但增加了清晰度和细节。

出于多种原因，这种解决方法在过去是无法实现的。尽管可改变用GDI库绘制的图形内容的大小，但User32不支持真正的缩放。

这个问题在WPF中不复存在，因为WPF自行渲染所有用户界面元素，从简单的形状到通用控件。所以，如果在计算机显示器上创建一个1英寸宽的按钮，在更高分辨率的显示器上它仍能保持1英寸的宽度——WPF只是使用更多像素更详细地渲染这个按钮罢了。

这里做了总体性描述，并通过几个细节进行了解释。最重要的是要认识到WPF根据系统DPI设置进行缩放，并不根据物理显示器设备的DPI进行缩放。这是十分合理的——毕竟在100英寸的投影仪上显示应用程序，您可能会站在投影仪后面几步远的地方，并希望看到特大版本的窗口。不希望WPF处理到正常大小。同样，如果使用高分辨率便携显示器，您可能希望窗口稍微小些。更进一步说，不同用户有不同偏好。有些用户可能希望显示更丰富的细节，而另一些用户肯呢过希望显示更多内容。

那么WPF如何确定应用程序窗口的大小呢？

简单来讲，就是当WPF计算窗口尺寸时使用系统DPI设置。但要想理解底层工作原理，进一步探讨WPF度量系统是很有帮助的。

##### 3.1 WPF单位

WPF窗口以及其中所有元素都使用与设备无关的单位进行度量。一个与设备无关的单位被定义为1/96英寸。

这样在设备上看一个表示的‘像素’就是有大有小的。

##### 3.2 系统DPI

如果改变系统DPI设置，WPF按钮示例就和其他类型Windows应用程序完全不同了。在上一代Windows中，该特性有时称为大字体。因为那时系统DPI会影响字体的大小，其他细节通常却不变。

这正是WPF的不同之处。WPF本身就可以十分轻松地支持DPI设置。WPF使用下面的公式计算如何将逻辑单位变换为物理设备像素：

	[物理单位尺寸] = [设备无关单位尺寸] X [系统DPI]

如果只用于按钮，这种自动缩放意义不大。但WPF对它所显示的任何内容都使用设备无关单位，包括形状、控件、文本以及其他放在窗口中的内容。所以可将系统dpi改为任何所希望的数值，WPF将无缝地调整应用程序的尺寸。

##### 3.3 位图和矢量图形

当使用普通控件时，自然可利用WPF的分辨无关性。WPF会负责确保任何显示内容都能自动地具有正确的尺寸。

但是，如果准备在应用程序中包含图像，偶尔可能出现问题。例如在传统Windows应用程序中，开发人员为工具栏命令按钮使用非常小的位图，但在WPF中这样并非一种理想方法，因为当根据系统DPI进行放大或缩小时，位图可能出现伪影（变得模糊）。

反而，当设计WPF用户界面时，即使是最小图标，通常也使用矢量图形来实现。矢量图形被定义为一系列的形状，并且它们能够很容易的缩放为任何尺寸。

分辨率无关性的重要性无论如何强调都不过分。因为乍一看，对于这个由来已久的问题（该问题确实如此），它看起来像是简单的、优美的解决方法。但为了设计完全可缩放的用户界面，开发人员需要接受一种新的思想。

### 4、WPF体系结构

### 5、WPF4.5

## 二、XAML ##

## 三、布局（Layout） ##

